<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dirt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0fdf4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #166534;
        }
        .container {
            width: 100%;
            max-width: 800px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        canvas {
            background-color: #d1fae5;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            height: auto;
            cursor: none; /* Hide the default cursor */
        }
    </style>
</head>
<body class="bg-emerald-50">

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-4">Interactive Dirt</h1>
        <canvas id="game-canvas" width="800" height="450"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            const DIRT_SIZE = 10;
            const DIRT_COLORS = ['#8B4513', '#6E3C0C', '#552D08', '#3C2005']; // Darker colors for deeper layers
            const NUM_LAYERS = 4;
            const DISPLACEMENT_RADIUS = 50;
            const SHOVEL_SIZE = 50;

            const gridWidth = Math.ceil(canvas.width / DIRT_SIZE);
            const gridHeight = Math.ceil(canvas.height / DIRT_SIZE);
            const dirtGrid = [];

            let mouseX = -100;
            let mouseY = -100;
            let isMouseDown = false;
            let moundDirt = [];
            let diggingOriginX = -1;
            let diggingOriginY = -1;

            for (let x = 0; x < gridWidth; x++) {
                dirtGrid[x] = [];
                for (let y = 0; y < gridHeight; y++) {
                    dirtGrid[x][y] = {
                        originalX: x * DIRT_SIZE,
                        originalY: y * DIRT_SIZE,
                        currentX: x * DIRT_SIZE,
                        currentY: y * DIRT_SIZE,
                        layer: Math.min(Math.floor(y / (gridHeight / NUM_LAYERS)), NUM_LAYERS - 1),
                        isMound: false,
                        isHole: false,
                        visible: true,
                    };
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw all dirt squares
                for (let x = 0; x < gridWidth; x++) {
                    for (let y = 0; y < gridHeight; y++) {
                        const dirt = dirtGrid[x][y];
                        if (dirt.visible) {
                            ctx.fillStyle = DIRT_COLORS[dirt.layer];
                            ctx.fillRect(dirt.currentX, dirt.currentY, DIRT_SIZE, DIRT_SIZE);
                        }
                    }
                }

                // Draw the shovel
                if (mouseX !== -100 && mouseY !== -100) {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(mouseX - SHOVEL_SIZE / 2, mouseY - SHOVEL_SIZE / 2, SHOVEL_SIZE, SHOVEL_SIZE);
                }
            }

            function updateDirt() {
                for (let x = 0; x < gridWidth; x++) {
                    for (let y = 0; y < gridHeight; y++) {
                        const dirt = dirtGrid[x][y];
                        
                        // Slowly return all dirt to its original position
                        dirt.currentX += (dirt.originalX - dirt.currentX) * 0.1;
                        dirt.currentY += (dirt.originalY - dirt.currentY) * 0.1;

                        if (isMouseDown) {
                            // Find the distance to the mouse from the dirt's original position
                            const dx = dirt.originalX - mouseX;
                            const dy = dirt.originalY - mouseY;
                            const distance = Math.hypot(dx, dy);

                            if (distance < DISPLACEMENT_RADIUS) {
                                // Check if this is the top visible layer
                                let isTopLayer = true;
                                for (let i = 0; i < y; i++) {
                                    if (dirtGrid[x][i].visible) {
                                        isTopLayer = false;
                                        break;
                                    }
                                }

                                if (isTopLayer) {
                                    dirt.visible = false;
                                    
                                    // Add to mound
                                    let foundMound = false;
                                    for(let i = 0; i < moundDirt.length; i++) {
                                        if (moundDirt[i].originalX === dirt.originalX && moundDirt[i].originalY === dirt.originalY) {
                                            moundDirt[i].x = mouseX + Math.random() * 20 - 10;
                                            moundDirt[i].y = mouseY + Math.random() * 20 - 10;
                                            foundMound = true;
                                            break;
                                        }
                                    }

                                    if (!foundMound) {
                                        moundDirt.push({
                                            originalX: dirt.originalX,
                                            originalY: dirt.originalY,
                                            x: mouseX + Math.random() * 20 - 10,
                                            y: mouseY + Math.random() * 20 - 10,
                                            layer: dirt.layer,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Update mound positions
                moundDirt = moundDirt.filter(dirt => {
                    const dx = dirt.x - mouseX;
                    const dy = dirt.y - mouseY;
                    return Math.hypot(dx, dy) < 200;
                });
            }

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            });
            
            canvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            function gameLoop() {
                updateDirt();
                draw();
                requestAnimationFrame(gameLoop);
            }

            gameLoop();
        });
    </script>
</body>
</html>
